<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cowboy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="css/main.css">
	</head>

	<body>
		<div class="wrapper">
			<ul>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
				<li></li>
			</ul>
		</div>
		<div id="info">
			<a href="#" target="_blank" rel="noopener">three.js</a> - Cowboy<br />
		</div>
		<main>
			<section class="back_section">
			</section>
			<section>
			</section>
			<section>
			</section>
			<section class="left_section">
				<p>
					SINCE THE BEGINNING,<br/>
					WE'VE BEEN DRIVEN<br/>
					TO EXPLORE
				</p>
			</section>

			<section class="left_section">
				<p>
					CALLED BY THE<br/>
					OPEN ROAD, AND THE<br/>
					SPIRIT OF ADVENTURE
				</p>
			</section>

			<section class="left_section">
				<p>
					TO SEEK THE THRILL<br/>
					OF HEADING INTO<br/>
					THE UNKNOWN
				</p>
			</section>

			<section class="right_section">
				<p>
					BUT TO GO WHERE WE WANT<br/>
					TO GO NEXT, WE NEED A<br/>
					NEW KIND OF FUEL
				</p>
			</section>
		</main>
		<!-- <div class='clouds'>
			<div class='clouds-1'></div>
			<div class='clouds-2'></div>
			<div class='clouds-3'></div>
		</div> -->
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
		<script src="./js/jquery-3.7.0.min.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./js/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from './js/OrbitControls.js';
			import { GLTFLoader } from './js/GLTFLoader.js';
			import { DRACOLoader } from './js/DRACOLoader.js';
			import { RGBELoader } from './js/RGBELoader.js';

			var controls, boom;
			var camera, scene, renderer, mixer, mixer1, clock, env_loader, cowboy_loader, title_loader;
			let smokeMaterial, smokeParticles = [], fogMaterial;
			var posZ = 90;
			var object, object1;
			let scrollPercent = 0;

			// const animationScripts: { start: number; end: number; func: () => void }[] = []
			var animationScripts = [];

			//add an animation that flashes the cube through 100 percent of scroll
			animationScripts.push({
				start: 0,
				end: 101,
				func: () => {
					if ( object !== undefined ) {
						boom.rotation.y = lerp(0, 4, scalePercent(1, 100));
					}
				},
			})

			//add an animation that moves the cube through first 40 percent of scroll
			animationScripts.push({
				start: 0,
				end: 20,
				func: () => {
					if ( object !== undefined ) {
					}
				},
			})

			//add an animation that rotates the cube between 40-60 percent of scroll
			animationScripts.push({
				start: 20,
				end: 30,
				func: () => {
					if ( object !== undefined ) {
						$(".left_section").eq(0).css('opacity', 1 - lerp(0, 1, scalePercent(20, 30)));
					}
				},
			})

			//add an animation that moves the camera between 60-80 percent of scroll
			animationScripts.push({
				start: 40,
				end: 50,
				func: () => {
					if ( object !== undefined ) {
						$(".left_section").eq(1).css('opacity', 1 - lerp(0, 1, scalePercent(40, 50)));
					}
				},
			})

			//add an animation that auto rotates the cube from 80 percent of scroll
			animationScripts.push({
				start: 60,
				end: 70,
				func: () => {
					if ( object !== undefined ) {
						$(".left_section").eq(2).css('opacity', 1 - lerp(0, 1, scalePercent(60, 70)));
					}
				},
			})

			//add an animation that auto rotates the cube from 80 percent of scroll
			animationScripts.push({
				start: 80,
				end: 90,
				func: () => {
					if ( object !== undefined ) {
						$(".right_section").eq(0).css('opacity', 1 - lerp(0, 1, scalePercent(80, 90)));
					}
				},
			})

			function playScrollAnimations() {
				animationScripts.forEach((a) => {
					if (scrollPercent >= a.start && scrollPercent < a.end) {
						a.func()
					}
				})
			}

			init();
			function init() {

				const container = document.createElement( 'div' );
				container.style.display = "none";
				document.body.appendChild( container );

				boom = new THREE.Group();
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );

				boom.add(camera);
				camera.position.set( -1.5, -1.2, -2.5 );

				const al = new THREE.AmbientLight(0xffffff, 0.7);
				boom.add( al );

				scene = new THREE.Scene();
				clock = new THREE.Clock();

				scene.add(boom);
				// scene.fog = new THREE.FogExp2( 0xffffff, 0.2 );
				// scene.fog = new THREE.Fog( 0xffffff, 0.015, 50 );

				new RGBELoader().load( './model/royal_esplanade_2k.hdr', function ( texture ) {
					texture.mapping = THREE.EquirectangularReflectionMapping;

					scene.background = texture;
					// scene.environment = texture;
					scene.environment = null;

					// render();

					// model
					const dracoLoader = new DRACOLoader();
					dracoLoader.setDecoderPath( 'draco/' );

					env_loader = new GLTFLoader();
					env_loader.setDRACOLoader( dracoLoader );

					env_loader.load( './model/env.gltf', function ( gltf ) {
						container.style.display = "block";
						$('.wrapper').addClass('hide');

						object = gltf.scene;

						scene.add( object );

						// const al = new THREE.AmbientLight(0xffffff, 4);
						// scene.add( al );
						// var light = new THREE.HemisphereLight(0xffffff, 0x0000ff, 1);
						// scene.add( light );
						// const dl = new THREE.DirectionalLight(0xffffff, 1);
						// dl.position.set(-250, -300, -25);
						// scene.add(dl);

						// const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
						// hemiLight.color.setHSL( 5, 1, 0.6 );
						// hemiLight.groundColor.setHSL( 5, 1, 1 );
						// hemiLight.position.set( 0, 0, 0 );
						// scene.add( hemiLight );

						// const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
						// scene.add( hemiLightHelper );

						const dirLight = new THREE.DirectionalLight( 'yellow', 5 );
						dirLight.color.setHSL( 0.6, 0.6, 1.3 );
						dirLight.position.set( 0, 14, 0 );
						dirLight.position.multiplyScalar( 20 );
						dirLight.target.position.set(0, 0, 0);
						scene.add( dirLight );

						// dirLight.castShadow = true;

						// dirLight.shadow.mapSize.width = 2048;
						// dirLight.shadow.mapSize.height = 2048;

						// const d = 50;

						// dirLight.shadow.camera.left = - d;
						// dirLight.shadow.camera.right = d;
						// dirLight.shadow.camera.top = d;
						// dirLight.shadow.camera.bottom = - d;

						// dirLight.shadow.camera.far = 500;
						// dirLight.shadow.bias = - 0.0001;

						// const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
						// scene.add( dirLightHelper );

						// console.log(object);
						// console.log(gltf.animations);
						mixer = new THREE.AnimationMixer( object );
						mixer.clipAction( gltf.animations[1] ).play();

						// gltf.animations[1].forEach( ( clip ) => {
						// 	mixer.clipAction( clip ).play();
						// } );

						mixer1 = new THREE.AnimationMixer( object );
						mixer1.timeScale = 0.05 ;
						mixer1.clipAction( gltf.animations[4] ).play();

						// gltf.animations[4].forEach( ( clip ) => {
						// 	mixer.clipAction( clip ).play();
						// } );
					} );

					title_loader = new GLTFLoader();
					title_loader.setDRACOLoader( dracoLoader );
					title_loader.load( './model/text.gltf', function ( gltf ) {
						// gltf.scene.scale.set(0.5, 0.5, 0.5);
						gltf.scene.position.setZ(35);
						gltf.scene.position.setY(-0.3);
						scene.add( gltf.scene );
					} );

					// cowboy_loader = new GLTFLoader();
					// cowboy_loader.setDRACOLoader( dracoLoader );

					// cowboy_loader.load( './model/cowboyhorse.gltf', function ( gltf ) {

					// 	object1 = gltf.scene;

					// 	scene.add( object1 );

					// 	// render();

					// 	mixer1 = new THREE.AnimationMixer( object1 );

					// 	gltf.animations.forEach( ( clip ) => {

					// 		mixer1.clipAction( clip ).play();

					// 	} );

					// } );

				} );

				const loader = new THREE.TextureLoader();

				loader.crossOrigin = '';

				loader.load('./model/blue-smoke3.png', function onLoad(texture) {
					const smokeGeo = new THREE.PlaneGeometry(600, 600);

					smokeMaterial = new THREE.MeshLambertMaterial({
						map: texture,
						transparent: true,
						side : THREE.BackSide,
						// wireframe: true
					});

					for (let p = 0, l = 2; p < l; p++) {
						// console.log(Math.random() * 300 % 5 * 200);
						let particle = new THREE.Mesh(smokeGeo, smokeMaterial);
						// particle.receiveShadow = true;
						// particle.castShadow = true;
						particle.frustumCulled = false;
						particle.position.set(
							-100 - (Math.random() * 300 % 5) * 10,
							15 + (Math.random() * 300 % 5),
							600 * p
						);

						particle.rotation.x = -Math.PI / 2;
						scene.add(particle);
						smokeParticles.push(particle);
					}

					const ambientLight = new THREE.AmbientLight(0xffffff, 1);
					scene.add(ambientLight);

					animate();
				});

				loader.load('./model/fog.png', function onLoad(texture) {
					const fogGeo = new THREE.PlaneGeometry(10, 5);

					fogMaterial = new THREE.MeshLambertMaterial({
						map: texture,
						transparent: true,
						side : THREE.BackSide,
						opacity : 0.7,
						// wireframe: true
					});

					let particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.frustumCulled = false;
					particle.position.set( 55, 2.5, 10 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( 42, 2.1, 25 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( 42, 2.5, 17 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( 22, 2.1, -22 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( 43, 3.5, -52 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( 43, 3.5, -60 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( 43, 4, -68 );
					particle.rotation.y = Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( -35, 2.2, 21 );
					particle.rotation.y = -Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( -40, 2.5, 15 );
					particle.rotation.y = -Math.PI / 2;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( -27, 2.2, -35 );
					particle.rotation.y = -Math.PI / 2 - 0.6;
					scene.add(particle);

					particle = new THREE.Mesh(fogGeo, fogMaterial);
					particle.position.set( -24, 1.3, -42 );
					particle.rotation.y = -Math.PI / 2 - 0.6;
					scene.add(particle);
				});
				// const al = new THREE.AmbientLight(0x00000000, 1);
				// scene.add( al );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				// renderer.setClearColor( 0x000000, 0 );
				// renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.toneMappingExposure = 1;
				// renderer.backgroundBlurriness = 1;
				// renderer.backgroundIntensity = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				// renderer.gammaInput = true;
        		// renderer.gammaOutput = true;
				container.appendChild( renderer.domElement );

				// const environment = new RoomEnvironment( renderer );
				// const pmremGenerator = new THREE.PMREMGenerator( renderer );
				// scene.background = new THREE.Color( 0xbbbbbb );
				// scene.environment = pmremGenerator.fromScene( environment ).texture;

				controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 6;
				controls.maxDistance = 7;
				controls.minPolarAngle = 1.3;
				controls.maxPolarAngle = 1.4;
				controls.target.set( 0, 1.9, 0 );
				controls.enableZoom = false;      //Zooming
    			// controls.autoRotate = true;
				// controls.enableDamping = true;
				controls.update();
				controls.enabled = false;

				window.addEventListener( 'resize', onWindowResize );

				window.scrollTo({ top: 0, behavior: 'smooth' })
				animate();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			/* Liner Interpolation
			* lerp(min, max, ratio)
			* eg,
			* lerp(20, 60, .5)) = 40
			* lerp(-20, 60, .5)) = 20
			* lerp(20, 60, .75)) = 50
			* lerp(-20, -10, .1)) = -.19
			*/
			function lerp(x, y, a) {
				return (1 - a) * x + a * y;
			}

			// Used to fit the lerps to start and end at specific scrolling percentages
			function scalePercent(start, end) {
				return (scrollPercent - start) / (end - start);
			}

			document.body.onscroll = () => {
				//calculate the current scroll progress as a percentage
				scrollPercent =
					((document.documentElement.scrollTop || document.body.scrollTop) /
						((document.documentElement.scrollHeight ||
							document.body.scrollHeight) -
							document.documentElement.clientHeight)) *
					100
				;
			}

			function animate() {
				requestAnimationFrame( animate );

				playScrollAnimations()

				// posZ -= 0.2;
				// if ( posZ < -40 )
				// 	posZ = 80;

				// if ( object !== undefined && object.position !== undefined )
				// 	object.position.setZ(posZ);

				var delta = clock.getDelta();
				if ( mixer ) mixer.update( delta );
				if ( mixer1 ) mixer1.update( delta );

				render();

				[].forEach.call(smokeParticles, sp => {
					// sp.rotation.z += delta * 0.2;
					sp.position.z -= delta * 10;

					if ( sp.position.z < -600 ) {
						// console.log(Math.random() * 300 % 5 * 200);
						sp.position.z = 600;
					}
				});

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
